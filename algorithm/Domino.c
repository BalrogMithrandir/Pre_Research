#include <stdio.h>
#include "Sort.h"
/*
第五次作业： 多米诺骨牌的动态规划解法
题目：现有n块“多米诺骨牌”S1，S2，„„，Sn水平放成一排，每块骨牌Si包含左右两个部分，
每个部分赋予一个非负整数值，如下图所示为包含6块骨牌的序列。骨牌可做180度旋转，
使得原来在左边的值变到右边，而原来在右边的值移到左边，假设不论si如何旋转，
L[i]总是存储si左边的值，R[i]总是存储右边的值，W[i]用于存储si的状态：
L[i]<=R[i]时记为0，否则记为1，试设计时间复杂度为O(n)的动态规划算法求
  最大值，以及当取得最大之时每个骨牌的状态。解：
*/

void domino_dynamic(int *L, int *R, int *W, int N)
{
    int i;
    /*M[0][i]: W[i]=0时，0到i的最大值
    M[1][i]: W[i]=1时，0到i的最大值*/
    int *M = malloc(sizeof(int)*N*2);

    /*M[0][i]: W[i]=0时，0到i取最大值时W[i-1]的状态
    M[1][i]: W[i]=1时，0到i取最大值是W[i-1]的状态*/
    int *P = malloc(sizeof(int)*N*2);
    for (i = 0; i < N; i++)
    {
        if (W[i] == 1)
        {
            Swap(L[i], R[i]);
            W[i] = 0;
        }
    }

    M[0][0] = 0;
    M[1][0] = 0;

    for (i = 1; i < N; i++)
    {
        S = L[i];
        B = R[i];

        m_0_0 = M[0][i-1] + R[i-1]*S;
        m_1_0 = M[1][i-1] + L[i-1]*S;
        if (m_0_0 > m_1_0)
        {
            M[0][i] = m_0_0;
            P[0][i] = 0;
        }
        else
        {
            M[0][i] = m_1_0;
            P[0][i] = 1;
        }


        m_0_1 = M[0][i-1] + R[i-1]*B;
        m_1_1 = M[1][i-1] + L[i-1]*B;
        if (m_0_1 > m_1_1)
        {
            M[1][i] = m_0_1;
            P[1][i] = 0;
        }
        else
        {
            M[1][i] = m_1_1;
            P[1][i] = 1;
        }
    }
    if (M[0][N-1] > M[1][N-1])
    {
        W[N-1] = 0;
    }
    else
    {
        W[N-1] = 1;
    }
    for (i = N-2; i > 0; i--)
    {
        if (W[i+1] == 1)
        {
            W[i] = P[1][i+1];
        }
        else
        {
            W[i] = P[0][i+1];
        }
    }
}
